#include<stdio.h>
#include<stdlib.h>
#include<conio.h>
#include<string.h>


// Wielkosc bloku w bitach/32
int Nr=0;
// Wielkosc klucza w bitach/32
int Nk=0;
//Licza kolumn stanowi¹cych stan w AES.
#define Nb = 4

// in - tablica danych wejsciowych
// out - tablica danych zaszyfrowanych
// state - szyfr poœredni zwany stanem
unsigned char in[16], out[16], stan[4][4], inde[16], outde[16];

// Tablica przechowuj¹ca klucze rundy
unsigned char RoundKey[240];

// Klucz wejsciowy do szyfrowania
unsigned char Key[32];


int Sbox[256] = { 
		0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
		0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
		0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
		0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
		0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
		0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
		0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
		0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
		0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
		0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
		0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
		0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
		0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
		0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
		0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
		0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16};
int PobierzWartSBox(int num)
{
return Sbox[num];
}

int invSbox[256] = { 
		0x52 ,0x09 ,0x6A ,0xD5 ,0x30 ,0x36 ,0xA5 ,0x38 ,0xBF ,0x40 ,0xA3 ,0x9E ,0x81 ,0xF3 ,0xD7 ,0xFB
		,0x7C ,0xE3 ,0x39 ,0x82 ,0x9B ,0x2F ,0xFF ,0x87 ,0x34 ,0x8E ,0x43 ,0x44 ,0xC4 ,0xDE ,0xE9 ,0xCB
		,0x54 ,0x7B ,0x94 ,0x32 ,0xA6 ,0xC2 ,0x23 ,0x3D ,0xEE ,0x4C ,0x95 ,0x0B ,0x42 ,0xFA ,0xC3 ,0x4E
		,0x08 ,0x2E ,0xA1 ,0x66 ,0x28 ,0xD9 ,0x24 ,0xB2 ,0x76 ,0x5B ,0xA2 ,0x49 ,0x6D ,0x8B ,0xD1 ,0x25
		,0x72 ,0xF8 ,0xF6 ,0x64 ,0x86 ,0x68 ,0x98 ,0x16 ,0xD4 ,0xA4 ,0x5C ,0xCC ,0x5D ,0x65 ,0xB6 ,0x92
		,0x6C ,0x70 ,0x48 ,0x50 ,0xFD ,0xED ,0xB9 ,0xDA ,0x5E ,0x15 ,0x46 ,0x57 ,0xA7 ,0x8D ,0x9D ,0x84
		,0x90 ,0xD8 ,0xAB ,0x00 ,0x8C ,0xBC ,0xD3 ,0x0A ,0xF7 ,0xE4 ,0x58 ,0x05 ,0xB8 ,0xB3 ,0x45 ,0x06
		,0xD0 ,0x2C ,0x1E ,0x8F ,0xCA ,0x3F ,0x0F ,0x02 ,0xC1 ,0xAF ,0xBD ,0x03 ,0x01 ,0x13 ,0x8A ,0x6B
		,0x3A ,0x91 ,0x11 ,0x41 ,0x4F ,0x67 ,0xDC ,0xEA ,0x97 ,0xF2 ,0xCF ,0xCE ,0xF0 ,0xB4 ,0xE6 ,0x73
		,0x96 ,0xAC ,0x74 ,0x22 ,0xE7 ,0xAD ,0x35 ,0x85 ,0xE2 ,0xF9 ,0x37 ,0xE8 ,0x1C ,0x75 ,0xDF ,0x6E
		,0x47 ,0xF1 ,0x1A ,0x71 ,0x1D ,0x29 ,0xC5 ,0x89 ,0x6F ,0xB7 ,0x62 ,0x0E ,0xAA ,0x18 ,0xBE ,0x1B
		,0xFC ,0x56 ,0x3E ,0x4B ,0xC6 ,0xD2 ,0x79 ,0x20 ,0x9A ,0xDB ,0xC0 ,0xFE ,0x78 ,0xCD ,0x5A ,0xF4
		,0x1F ,0xDD ,0xA8 ,0x33 ,0x88 ,0x07 ,0xC7 ,0x31 ,0xB1 ,0x12 ,0x10 ,0x59 ,0x27 ,0x80 ,0xEC ,0x5F
		,0x60 ,0x51 ,0x7F ,0xA9 ,0x19 ,0xB5 ,0x4A ,0x0D ,0x2D ,0xE5 ,0x7A ,0x9F ,0x93 ,0xC9 ,0x9C ,0xEF
		,0xA0 ,0xE0 ,0x3B ,0x4D ,0xAE ,0x2A ,0xF5 ,0xB0 ,0xC8 ,0xEB ,0xBB ,0x3C ,0x83 ,0x53 ,0x99 ,0x61
		,0x17 ,0x2B ,0x04 ,0x7E ,0xBA ,0x77 ,0xD6 ,0x26 ,0xE1 ,0x69 ,0x14 ,0x63 ,0x55 ,0x21 ,0x0C ,0x7D};
int PobierzWartinvSBox(int num)
{
return invSbox[num];
}

//Tablica sta³ych s³ów rundy zawiera wartoœci x do potêgi i-1 bêd¹cymi potêgami x w ciele GF(28)
//i zaczyna siê od 1, nie od 0
int Rcon[255] = {
    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb  };


int	E[16][16] = {
	// 0	1	   2	 3	   4	5	  6	     7	   8	9	   A	 B	   C	D	   E	 F
	 0x01, 0x03, 0x05, 0x0F, 0x11, 0x33, 0x55, 0xFF, 0x1A, 0x2E, 0x72, 0x96, 0xA1, 0xF8, 0x13, 0x35,	//0
	 0x5F, 0xE1, 0x38, 0x48, 0xD8, 0x73, 0x95, 0xA4, 0xF7, 0x02, 0x06, 0x0A, 0x1E, 0x22, 0x66, 0xAA,	//1
	 0xE5, 0x34, 0x5C, 0xE4, 0x37, 0x59, 0xEB, 0x26, 0x6A, 0xBE, 0xD9, 0x70, 0x90, 0xAB, 0xE6, 0x31,	//2
	 0x53, 0xF5, 0x04, 0x0C, 0x14, 0x3C, 0x44, 0xCC, 0x4F, 0xD1, 0x68, 0xB8, 0xD3, 0x6E, 0xB2, 0xCD,	//3
	 0x4C, 0xD4, 0x67, 0xA9, 0xE0, 0x3B, 0x4D, 0xD7, 0x62, 0xA6, 0xF1, 0x08, 0x18, 0x28, 0x78, 0x88,	//4
	 0x83, 0x9E, 0xB9, 0xD0, 0x6B, 0xBD, 0xDC, 0x7F, 0x81, 0x98, 0xB3, 0xCE, 0x49, 0xDB, 0x76, 0x9A,	//5
	 0xB5, 0xC4, 0x57, 0xF9, 0x10, 0x30, 0x50, 0xF0, 0x0B, 0x1D, 0x27, 0x69, 0xBB, 0xD6, 0x61, 0xA3,	//6
	 0xFE, 0x19, 0x2B, 0x7D, 0x87, 0x92, 0xAD, 0xEC, 0x2F, 0x71, 0x93, 0xAE, 0xE9, 0x20, 0x60, 0xA0,	//7
	 0xFB, 0x16, 0x3A, 0x4E, 0xD2, 0x6D, 0xB7, 0xC2, 0x5D, 0xE7, 0x32, 0x56, 0xFA, 0x15, 0x3F, 0x41,	//8
	 0xC3, 0x5E, 0xE2, 0x3D, 0x47, 0xC9, 0x40, 0xC0, 0x5B, 0xED, 0x2C, 0x74, 0x9C, 0xBF, 0xDA, 0x75,	//9
	 0x9F, 0xBA, 0xD5, 0x64, 0xAC, 0xEF, 0x2A, 0x7E, 0x82, 0x9D, 0xBC, 0xDF, 0x7A, 0x8E, 0x89, 0x80,	//A
	 0x9B, 0xB6, 0xC1, 0x58, 0xE8, 0x23, 0x65, 0xAF, 0xEA, 0x25, 0x6F, 0xB1, 0xC8, 0x43, 0xC5, 0x54,    //B
	 0xFC, 0x1F, 0x21, 0x63, 0xA5, 0xF4, 0x07, 0x09, 0x1B, 0x2D, 0x77, 0x99, 0xB0, 0xCB, 0x46, 0xCA,	//C
	 0x45, 0xCF, 0x4A, 0xDE, 0x79, 0x8B, 0x86, 0x91, 0xA8, 0xE3, 0x3E, 0x42, 0xC6, 0x51, 0xF3, 0x0E,	//D
	 0x12, 0x36, 0x5A, 0xEE, 0x29, 0x7B, 0x8D, 0x8C, 0x8F, 0x8A, 0x85, 0x94, 0xA7, 0xF2, 0x0D, 0x17,	//E
	 0x39, 0x4B, 0xDD, 0x7C, 0x84, 0x97, 0xA2, 0xFD, 0x1C, 0x24, 0x6C, 0xB4, 0xC7, 0x52, 0xF6, 0x01	    //F
};

int	L[16][16] = {
	// 0	1	   2	 3	   4	 5	   6	 7	   8	9	  A	    B	  C	     D	   E	 F
	 0x00 ,0x00 ,0x19 ,0x01 ,0x32 ,0x02 ,0x1A ,0xC6 ,0x4B ,0xC7 ,0x1B ,0x68 ,0x33 ,0xEE ,0xDF ,0x03,	//0
	 0x64 ,0x04 ,0xE0 ,0x0E ,0x34 ,0x8D ,0x81 ,0xEF ,0x4C ,0x71 ,0x08 ,0xC8 ,0xF8 ,0x69 ,0x1C ,0xC1,	//1
	 0x7D ,0xC2 ,0x1D ,0xB5 ,0xF9 ,0xB9 ,0x27 ,0x6A ,0x4D ,0xE4 ,0xA6 ,0x72 ,0x9A ,0xC9 ,0x09 ,0x78,	//2
	 0x65 ,0x2F ,0x8A ,0x05 ,0x21 ,0x0F ,0xE1 ,0x24 ,0x12 ,0xF0 ,0x82 ,0x45 ,0x35 ,0x93 ,0xDA ,0x8E,	//3
	 0x96 ,0x8F ,0xDB ,0xBD ,0x36 ,0xD0 ,0xCE ,0x94 ,0x13 ,0x5C ,0xD2 ,0xF1 ,0x40 ,0x46 ,0x83 ,0x38,	//4
	 0x66 ,0xDD ,0xFD ,0x30 ,0xBF ,0x06 ,0x8B ,0x62 ,0xB3 ,0x25 ,0xE2 ,0x98 ,0x22 ,0x88 ,0x91 ,0x10,	//5
	 0x7E ,0x6E ,0x48 ,0xC3 ,0xA3 ,0xB6 ,0x1E ,0x42 ,0x3A ,0x6B ,0x28 ,0x54 ,0xFA ,0x85 ,0x3D ,0xBA,	//6
	 0x2B ,0x79 ,0x0A ,0x15 ,0x9B ,0x9F ,0x5E ,0xCA ,0x4E ,0xD4 ,0xAC ,0xE5 ,0xF3 ,0x73 ,0xA7 ,0x57,	//7
	 0xAF ,0x58 ,0xA8 ,0x50 ,0xF4 ,0xEA ,0xD6 ,0x74 ,0x4F ,0xAE ,0xE9 ,0xD5 ,0xE7 ,0xE6 ,0xAD ,0xE8,	//8
	 0x2C ,0xD7 ,0x75 ,0x7A ,0xEB ,0x16 ,0x0B ,0xF5 ,0x59 ,0xCB ,0x5F ,0xB0 ,0x9C ,0xA9 ,0x51 ,0xA0,	//9
	 0x7F ,0x0C ,0xF6 ,0x6F ,0x17 ,0xC4 ,0x49 ,0xEC ,0xD8 ,0x43 ,0x1F ,0x2D ,0xA4 ,0x76 ,0x7B ,0xB7,	//A
	 0xCC ,0xBB ,0x3E ,0x5A ,0xFB ,0x60 ,0xB1 ,0x86 ,0x3B ,0x52 ,0xA1 ,0x6C ,0xAA ,0x55 ,0x29 ,0x9D,	//B
	 0x97 ,0xB2 ,0x87 ,0x90 ,0x61 ,0xBE ,0xDC ,0xFC ,0xBC ,0x95 ,0xCF ,0xCD ,0x37 ,0x3F ,0x5B ,0xD1,	//C
	 0x53 ,0x39 ,0x84 ,0x3C ,0x41 ,0xA2 ,0x6D ,0x47 ,0x14 ,0x2A ,0x9E ,0x5D ,0x56 ,0xF2 ,0xD3 ,0xAB,	//D
	 0x44 ,0x11 ,0x92 ,0xD9 ,0x23 ,0x20 ,0x2E ,0x89 ,0xB4 ,0x7C ,0xB8 ,0x26 ,0x77 ,0x99 ,0xE3 ,0xA5,	//E
	 0x67 ,0x4A ,0xED ,0xDE ,0xC5 ,0x31 ,0xFE ,0x18 ,0x0D ,0x63 ,0x8C ,0x80 ,0xC0 ,0xF7 ,0x70 ,0x07		//F
};




//=============================================================================================================================

void GenerujKlucz()
{
	int i,j;
	unsigned char temp[4],k;

	//Pierwsza runda jest kluczem samym w sobie
	for(i=0; i<Nk; i++)
	{
		RoundKey[i*4] = Key[i*4];
		RoundKey[i*4+1] = Key[i*4+1];
		RoundKey[i*4+2] = Key[i*4+2];
		RoundKey[i*4+3] = Key[i*4+3];
	}

	//Wszystkie inne klucze rundy tworzy siê na podstawie poprzednich
	while (i < (4 * (Nr+1)))
	{
		for(j=0; j<4; j++)
		{
			temp[j] = RoundKey[(i-1) * 4 + j];
		}
		if(i % Nk == 0)
		{
			//Ta funkcja obraca 4 bajtowe s³owo w lewo
			//[a0,a1,a2,a3] do [a1,a2,a3,a0];
			{
				k = temp[0];
				temp[0] = temp[1];
				temp[1] = temp[2];
				temp[2] = temp[3];
				temp[3] = k;
			}
			//Konwersja wartœci czterobajtowych na wartoœci z macierzy S-Box
			{
				temp[0] = PobierzWartSBox(temp[0]);
				temp[1] = PobierzWartSBox(temp[1]);
				temp[2] = PobierzWartSBox(temp[2]);
				temp[3] = PobierzWartSBox(temp[3]);
			}
			temp[0] = temp[0] ^ Rcon[i/Nk];
		}
		else if (Nk>6 && i%Nk == 4)
		{
			//Konwersja wartœci czterobajtowych na wartoœci z macierzy S-Box
			{
				temp[0] = PobierzWartSBox(temp[0]);
				temp[1] = PobierzWartSBox(temp[1]);
				temp[2] = PobierzWartSBox(temp[2]);
				temp[3] = PobierzWartSBox(temp[3]);
			}
		}
		RoundKey[i*4+0] = RoundKey[(i-Nk)*4+0] ^temp[0];
		RoundKey[i*4+1] = RoundKey[(i-Nk)*4+1] ^temp[1];
		RoundKey[i*4+2] = RoundKey[(i-Nk)*4+2] ^temp[2];
		RoundKey[i*4+3] = RoundKey[(i-Nk)*4+3] ^temp[3];
		i++;
	}
}
//=============================================================================================================================
void SubBytes()
{
	int i,j;
	for(i=0 ; i<4 ; i++)
	{
		for(j=0 ; j<4 ; j++)
		{
			stan[i][j] = PobierzWartSBox(stan[i][j]);
		}
	}
}
//------------------------------------------------------------------------
void invSubBytes()
{
	int i,j;
	for(i=0 ; i<4 ; i++)
	{
		for(j=0 ; j<4 ; j++)
		{
			stan[i][j] = PobierzWartinvSBox(stan[i][j]);
		}
	}
}

//=============================================================================================================================

void ShiftRows()
{	
	unsigned char temp;

	//w lewo o C1 (1 dla Ns = 4)
	temp = stan[1][0];
	stan[1][0] = stan[1][1];
	stan[1][1] = stan[1][2];
	stan[1][2] = stan[1][3];
	stan[1][3] = temp;

	//w lewo o C2 (2 dla Ns = 4)
	temp = stan[2][0];
	stan[2][0] = stan[2][2];
	stan[2][2] = temp;
	temp = stan[2][1];
	stan[2][1] = stan[2][3];
	stan[2][3] = temp;
	
	//w lewo o C3 (3 dla Ns = 4)
	temp = stan[3][0];
	stan[3][0] = stan[3][3];
	stan[3][3] = stan[3][2];
	stan[3][2] = stan[3][1];
	stan[3][1] = temp;
}
//------------------------------------------------------------------------
void invShiftRows()
{	
	unsigned char temp;

	//w prawo o C1 (1 dla Ns = 4)
	temp = stan[3][0];
	stan[3][0] = stan[3][1];
	stan[3][1] = stan[3][2];
	stan[3][2] = stan[3][3];
	stan[3][3] = temp;

	//w prawo o C2 (2 dla Ns = 4)
	temp = stan[2][0];
	stan[2][0] = stan[2][2];
	stan[2][2] = temp;
	temp = stan[2][1];
	stan[2][1] = stan[2][3];
	stan[2][3] = temp;
	
	//w prawo o C3 (3 dla Ns = 4)
	temp = stan[1][3];
	stan[1][3] = stan[1][2];
	stan[1][2] = stan[1][1];
	stan[1][1] = stan[1][0];
	stan[1][0] = temp;
}
//=============================================================================================================================

// algorytm MixColumns() z wykorzystaniem LookUpTable
void MixColumns()
{

	unsigned char mix[4][4] = { 0x02, 0x03, 0x01, 0x01,
								0x01, 0x02, 0x03, 0x01,
								0x01, 0x01, 0x02, 0x03,
								0x03, 0x01, 0x01, 0x02 };

	int i,j,k;
	unsigned char _stan[4][4],t1,t2,t,temp;
	for(j=0;j<4;j++)
    {    
		for(i=0;i<4;i++)
		{    
			_stan[i][j] = stan[i][j];
		}
	}
	for(j=0;j<4;j++)
    {    
		for(i=0;i<4;i++)
		{    
			temp = 0x00;
			 for(k=0;k<4;k++)
			 {   	 
				 if( _stan[k][j] == 0) t=0;
				 else
				 {
					 if(mix[i][k]!=0x01)
					 {

						t1 = L[ _stan[k][j]>>4 ][ _stan[k][j] & 0x0F ];
						t2 = L[ mix[i][k]>>4 ][ mix[i][k] & 0x0F ];

						if((t1+t2)>0xFF) 
							t = t1 + t2 - 0xFF;
						else
							t = t1+t2;

						t = E[ t>>4 ][ t & 0x0F ];
					 }
					 else
					 {
						t = _stan[k][j];
					 }		
				 }
				 temp = temp ^ t;
			 }  
			 stan[i][j] = temp;
		}
	}
}

//------------------------------------------------------------------------
void invMixColumns()
{

	int mix[4][4] = { 0x0E, 0x0B, 0x0D, 0x09,
					  0x09, 0x0E, 0x0B, 0x0D,
					  0x0D, 0x09, 0x0E, 0x0B,
					  0x0B, 0x0D, 0x09, 0x0E };

	int i,j,k;
	unsigned char _stan[4][4],t1,t2,t,temp;
	for(j=0;j<4;j++)
    {    
		for(i=0;i<4;i++)
		{    
			_stan[i][j] = stan[i][j];
		}
	}
	for(j=0;j<4;j++)
    {    
		for(i=0;i<4;i++)
		{    
			temp = 0x00;
			 for(k=0;k<4;k++)
			 {   	 
				 if( _stan[k][j] == 0) t=0;
				 else
				 {
					 if(mix[i][k]!=0x01)
					 {

						t1 = L[ _stan[k][j]>>4 ][ _stan[k][j] & 0x0F ];
						t2 = L[ mix[i][k]>>4 ][ mix[i][k] & 0x0F ];

						if((t1+t2)>0xFF) 
							t = t1 + t2 - 0xFF;
						else
							t = t1+t2;

						t = E[ t>>4 ][ t & 0x0F ];
					 }
					 else
					 {
						t = _stan[k][j];
					 }		
				 }
				 temp = temp ^ t;
			 }  
			 stan[i][j] = temp;
		}
	}
}

//=============================================================================================================================

void AddRoundKey(int runda)
{
	int i,j;
	for(i=0; i<4; i++)
	{
		for(j=0; j<4; j++)
		{
			stan[j][i] ^=RoundKey[runda * 4 * 4 + i * 4 +j];
		}
	}
}

// Funkcja rozpoczynaj¹ca szyfrowanie tablicy znaków in[]
void Szyfruj()
{
    int i,j,runda=0;

    //Transformacja tablicy znaków w macierz stanu
    for(i=0;i<4;i++)
    {
        for(j=0;j<4;j++)
        {
            stan[j][i] = in[i*4 + j];
        }
    }

    // Dodanie pierwszego klucza rundy do stanu
    AddRoundKey(0); 
    
    //Pierwsze Nr-1 rund
    for(runda=1 ; runda<Nr ; runda++)
    {
        SubBytes();
        ShiftRows();
        MixColumns();
        AddRoundKey(runda);
    }

	//Ostatnia runda
    SubBytes();
    ShiftRows();
    AddRoundKey(Nr);

    //Kopiowanie zaszyfrowanego tekstu na wyjscie
    for(i=0;i<4;i++)
    {
        for(j=0;j<4;j++)
        {
            out[i*4+j]=stan[j][i];
        }
    }
}

void Deszyfruj()
{
	int i,j,round=0;
	//Kopiowanie zaszyfrowanego tekstu do tablicy stanów
	for(i=0; i<4; i++)
	{
		for(j=0; j<4; j++)
		{
			stan[j][i] = inde[i*4+j];
		}
	}
	//Dodanie pierwszego klucza rundy
	AddRoundKey(Nr);
	for(round = Nr-1; round>0; round--)
	{
		invShiftRows();
		invSubBytes();
		invShiftRows();
		invMixColumns();
	}
	//Ostatnia runda
	invShiftRows();
	invSubBytes();
	AddRoundKey(0);
	//Kopiowanie wyniku do macierzy wyjœciowej
	for(i=0; i<4; i++)
	{
		for(j=0; j<4; j++)
		{
			outde[i*4+j] = stan[j][i];
		}
	}
}

//=============================================================================================================================

void WyswietlStan()
{
	int i,j;
	for(i=0 ; i<4 ; i++)
	{
		printf("\n");
		for(j=0 ; j<4 ; j++)
		{
			printf("%x , ",stan[i][j]);
		}
	}
	system("pause");
}

//=============================================================================================================================
int main()
{
	int i, j;
	// Wiadomosc "Wesolych_swiat!!"
	unsigned char wiadomosc[16] = {0x57, 0x65, 0x73, 0x6F, 0x6C, 0x79, 0x63, 0x68, 0x20, 0x73, 0x77, 0x69, 0x61, 0x74, 0x21, 0x21}; 
    unsigned char temp2[16] = {0xdc, 0x18, 0xa3, 0x3d, 0xf3, 0x21, 0xbe, 0xe8, 0xa5, 0x6a, 0x83, 0x70, 0xf7, 0x59, 0x24, 0x7d};
	//temp - klucz
	unsigned char temp[16] = {0x00  ,0x01  ,0x02  ,0x03  ,0x04  ,0x05  ,0x06  ,0x07  ,0x08  ,0x09  ,0x0a  ,0x0b  ,0x0c  ,0x0d  ,0x0e  ,0x0f};
	
    while(Nr!=128 && Nr!=192 && Nr!=256)
    {
        printf("Wybierz dlugosc klucza:(128, 192 lub 256): ");
        scanf("%d",&Nr);
    }
    
    // obliczenie Nk i Nr
    Nk = Nr / 32;
    Nr = Nk + 6;

	for(i=0 ; i < Nk*4 ; i++)
	{
		in[i] = wiadomosc[i];
		Key[i] = temp[i];
	}
	GenerujKlucz();
	Szyfruj();
	printf("Szyfrujemy: Wesolych Swiat!! 0x57, 0x65, 0x73, 0x6F, 0x6C, 0x79, 0x63, 0x68, 0x20, 0x73, 0x77, 0x69, 0x61, 0x74, 0x21, 0x21\n");
	printf("Tekst po szyfryzacji: \n");
	for(i=0; i<Nk*4; i++)
	{
		printf("%02x",out[i]);
	}	
	printf("\n");
	printf("Tekst po deszyfryzacji:  ");

	for(i=0 ; i < Nk*4 ; i++)
	{
		inde[i] = temp2[i];
		Key[i] = temp[i];
	}
	GenerujKlucz();
	Deszyfruj();
	for(i=0; i<Nk*4; i++)
	{
		printf("%02x ",outde[i]);
	}
	getch();
}